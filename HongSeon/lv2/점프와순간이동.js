// n이 목표거리
// 점프시 이동한 만큼 배터리 소모
// 순간이동시 현재까리 거리 누적*2로 이동 배터리소모x (순간이동이 무한인가? 무한인 것 같다)
// 이진수를 이용해 접근 (이진수의 1의 갯수가 곧 배터리 소모 수)

// ex) 
// 5 = 101
// 일단 목표거리를 2로 나눠 나머지가 1일 때 count를 증가시키는 것을 반복 
// 5를 2로 나누고 몫:2 나머지 1  
// 2을 2로 나누고 몫:1 나머지 0  
// 1을 2로 나누고 몫:0 나머지 1
// 최종 몫이 0이되면 종료

// 왜 이진수의 1의 갯수가 곧 배터리 소모 수 인가?
// ex) 맨 왼쪽비트부터 시작
// 5000 = 1 0011 1000 1000
// 1
// 2 => 4 => 9 => 19
// 39 => 78 => 156 => 312
// 625 => 1250 => 2500 => 5000

// 1은 순간이동 + 점프(순간이동 후 점프 순), 0은 그냥 순간이동
// 첫 번째 1은 무조건 점프만 


function solution(n) {
    let count = 0;
    while (n) {
        let remain = n % 2; // 나머지  
        if (remain === 1) {
            count++;  // 나머지가 1이면 count를 증가
        }
        n = Math.floor(n / 2);  // n을 2로 나눈 정수 부분 (Math.floor이용 안해주면 답 없음 20분 잡아먹음)
    }
    return count;  // 1의 개수를 반환
}


/* 시간복잡도
 - while루프(n이 0이 될 때까지 2로 나누는 연산) : O(logn)
 - count 증가(상수 시간) : O(1)

 => 코드 전체 시간 복잡도 : O(logn)
*/